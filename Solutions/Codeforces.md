只记录一些**临场没做出来/有意思**的题目



## CF 2026F (1037 Div3 F)

**题意**：给定一颗树，每个点有初始的颜色，每条边有边权。如果一条边两个端点的颜色不一致，就要付出对应边权的代价。有若干个操作，每个操作修改单点的颜色，每次操作后给出当前情况的总代价。

**非正解**：临场写了个分块的做法，记录每个节点周围各种颜色的权值和，定期重构

​            每次询问时，先利用上一次重构时记录的信息，然后再遍历从上一次重构到现在的修改来更新信息

​            因为用map来记录颜色权值和，所以总时间复杂度是$O(n\sqrt{n}\log n)$，提交后会部分TLE

**正解**：非正解的做法不仅可以处理树，也可以处理图，没有充分利用树的性质

​           正解是对每个节点维护他的孩子的各种颜色权值和

​           每次询问时，利用被修改的节点的孩子信息以及和父节点的关系就可以更新答案，然后修改在父节点维护的信息即可

​	   同样需要利用map来记录颜色权值和，总时间复杂度是$O(n\log n)$



## CF 2026G (1037 Div3 G)

**题意**：给定一个序列$A$，求序列的一个区间，使得**区间中位数减去区间最小值**最大

**正解**：

​	关于序列的中位数，有一个很常用的处理方法：

​		假设当前考虑的中位数为$X$，将序列中大于等于$X$的位置设为$1$，小于$X$的位置设为$-1$

​		序列区间$[L,R]$的和如果大于等于$0$，就说明区间$[L,R]$的中位数大于等于$X$，反之则小于$X$

​	先考虑一个子问题，假设我们已经确定$A[p]$是区间最小值，在这个前提条件下判断是否存在区间使得中位数大于等于$X$

​		首先利用单调栈可以求出$p$位置向左和向右的第一个小于$A[p]$的位置，分别记为$p_l$和$p_r$

​		按照上面的处理方式，将大于等于$X$的位置设为$1$，小于$X$的位置设为$-1$，记前缀和数组为$S$

​		只需要考虑$\max\{S[r]|p\leq r < p_r\} - \min\{S[l]\ p_l \leq p < p\}$是否大于零即可

​	对于确定的区间最小值$A[p]$，如果我们从小到大枚举可能的区间中位数，就可以用线段树支持动态区间加减和查询区间最大值/最小值来完成判断。

​	如果我们从小到大枚举可能的区间最小值$A[p]$，假设之前有中位数$X$满足条件，那么就不需要考虑小于等于$X$的中位数的可能性 (因为即使可行也一定不是最优)，只需从之前的可行最大中位数继续向上枚举判断即可。这样我们的总时间复杂度为$O(n\log n)$





